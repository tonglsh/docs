## MySQL事务的隔离级别

### 1 事务

事务只是一个改变，是一些操作的集合，用专业的术语讲，他就是一个程序的执行单元；**事务本身其实并不包含我们常讲的四个特性(ACID)**，我们需要通过某些手段，尽可能的让这个执行单元满足这四个特性，那么，我们就可以称他为一个事务，或者说是一个正确的事务，完美的事务。

> 事物的四个特性（ACID）
> atomicity：原子性 满足原子操作单元，对数据的操作，要么全都执行，要么全部回滚
>
> consistency：一致性 事务开始和完成 数据整体必须保持一致。 如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
>
> isolation：隔离性 事务之间相对独立，中间状态对外不可见，并发执行的各个事务之间不能互相干扰。
>
> durability：持久性 也称永久性事务一旦提交，；对数据的改变就是永久的，接下来的其他操作或故障不应对其执行结果有影响

### 2 隔离级别

##### 2.1  并发情况下事务引发的问题

> 一般情况下，多个单元操作并发执行，会出现这样的几个问题

* dirty read（脏读）：A事务还未提交，B事务就读到了A事务的结果。（破坏了 隔离性）

* non-repeatable read（不可重复读）：A事务在本次事务中，对自己未操作的数据，进行了多次的读取，出现了不一致或者不存在的情况。（破坏了一致性，update delete）
* phantom read（幻读）：A事务在本次操作中，对自己未操作的数据，进行了多次的读取，第一次读取时，记录不存在，第二次读取时，记录出现了（破坏了一致性，insert）

##### 2.2  解决(制定标准)

为了权衡 **隔离** 和 **并发** 的矛盾，ISO定义了四种事务的隔离级别，每个级别隔离程度不同，允许出现的副作用也不同。

* read-uncommitted（读 未提交）：最低的级别，只能保持持久性

> 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

* read-committed（读 提交；不可重复读）：语句级别

> 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Non-repeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

* repeatable-read（可重复读）：事务级别

> 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

* serializable（串行化）：最高级别，无并发，性能极低

> 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

| 事务隔离级别                          | 脏读 | 不可重复读 | 幻读 |
| ------------------------------------- | ---- | ---------- | ---- |
| read-uncommitted（读 未提交）         | 会   | 会         | 会   |
| read-committed（读 提交；不可重复读） | -    | 会         | 会   |
| repeatable-read（可重复读）           | -    | -          | 会   |
| serializable（串行化）                | -    | -          | -    |

##### 2.3  实现（InnoDB）

* 锁机制：阻止其他事务对数据进行操作，各个隔离级别主要体现在读取数据时加的锁和释放时机。
  * RU：事务读取的时候，不加锁
  * RC：事务读取的时候加行级共享锁（读到才加锁），一旦读完，立即释放（并不是事务结束）
  * RR：事务读取时加行级共享锁，直到事务结束才会释放
  * SE：事务读取时加表级共享锁，知道事务结束，才会释放
* MVCC机制：生成一个数据快照，并用这个快照来提供一定级别的一致性的读取，也成为了多版本数据控制。
  * 实际就是**CAS版本控制**  和  **读写分离**的思想
  * 主要作用于RC和RR级别

### 3 总结图

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20200424150957549.png" alt="image-20200424150957549" style="zoom:80%;" />

### 4 Tips

**引用一个 github 上面的评论 地址：**

Mysql官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读。


a事务先select，b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意dml操作），a事务再select出来的结果在MVCC下还和第一次select一样，接着a事务不加条件地update，这个update会作用在所有行上（包括b事务新加的），a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了，实测在RR级别下确实如此。


如果这样理解的话，MySQL的RR级别确实防不住幻读

*********************
**有道友回复 地址：**

在快照读读情况下，mysql通过mvcc来避免幻读。
在当前读读情况下，mysql通过next-key来避免幻读。
select * from t where a=1;属于快照读
select * from t where a=1 lock in share mode;属于当前读

不能把快照读和当前读得到的结果不一样这种情况认为是幻读，这是两种不同的使用。所以我认为mysql的rr级别是解决了幻读的。

先说结论，MySQL 存储引擎 InnoDB 隔离级别 RR 解决了幻读问题。面试问烂的 MySQL 四种隔离级别，这篇文章建议大家看下。


如引用一问题所说，T1 select 之后 update，会将 T2 中 insert 的数据一起更新，那么认为多出来一行，所以防不住幻读。看着说法无懈可击，但是其实是错误的，InnoDB 中设置了快照读和当前读两种模式，如果只有快照读，那么自然没有幻读问题，但是如果将语句提升到当前读，那么 T1 在 select 的时候需要用如下语法： select * from t for update (lock in share mode) 进入当前读，那么自然没有 T2 可以插入数据这一回事儿了。

***************
**注意**


**next-key 固然很好的解决了幻读问题，但是还是遵循一般的定律，隔离级别越高，并发越低。**



默认隔离级别都是第二级别的（mysql第三级别），要想彻底防止幻读需要提升手动设置隔离级别到最高级别。
但在提升事务隔离级别的同时，查询的效率会大大降低。
因此，如何优化精简你的事务代码也很重要，尽量避免幻读等情况的发生。